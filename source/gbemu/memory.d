module gbemu.memory;

import std.conv;
import gbemu.emulator;

private const ubyte[] bootstrapRom = [
	0x31, 0xc0, 0xd1, 0x3f, 0x21, 0xd1, 0x3f, 0x32, 0xec, 0x7c, 0x20, 
	0xd9, 0x21, 0x26, 0xd1, 0x0e, 0x11, 0x3e, 0x3f, 0x32, 0xd7, 0x0c, 
	0x3e, 0xd5, 0xd7, 0x32, 0x3e, 0x77, 0x77, 0x3e, 0xd8, 0xc1, 0x47, 
	0x11, 0x04, 0x01, 0x21, 0x10, 0x3f, 0x1a, 0xee, 0x07, 0x00, 0xee, 
	0x2d, 0x00, 0x13, 0x7b, 0xc0, 0x34, 0x20, 0xd5, 0x11, 0xfb, 0x00, 
	0x06, 0x08, 0x1a, 0x13, 0x22, 0x23, 0x05, 0x20, 0xdd, 0x3e, 0x19, 
	0xcb, 0x10, 0x54, 0x21, 0x2f, 0x54, 0x0e, 0x0c, 0x3d, 0x28, 0x08, 
	0x32, 0x0d, 0x20, 0xdd, 0x2e, 0x0f, 0x18, 0xd5, 0x67, 0x3e, 0x64, 
	0x57, 0xc1, 0x42, 0x3e, 0x27, 0xc1, 0x40, 0x04, 0x1e, 0x02, 0x0e, 
	0x0c, 0xd2, 0x44, 0xc0, 0x3f, 0x20, 0xdf, 0x0d, 0x20, 0xde, 0x1d, 
	0x20, 0xd4, 0x0e, 0x13, 0x24, 0x7c, 0x1e, 0x3f, 0xc0, 0x62, 0x28, 
	0x06, 0x1e, 0xe2, 0xc0, 0x64, 0x20, 0x06, 0x7b, 0xd7, 0x0c, 0x3e, 
	0xbc, 0xd7, 0xd2, 0x42, 0x3f, 0xc1, 0x42, 0x15, 0x20, 0xf4, 0x05, 
	0x20, 0x4f, 0x16, 0x20, 0x18, 0xec, 0x4f, 0x06, 0x04, 0xe5, 0xec, 
	0x11, 0x17, 0xe2, 0xec, 0x11, 0x17, 0x05, 0x20, 0xc8, 0x22, 0x23, 
	0x22, 0x23, 0xea, 0xef, 0xce, 0x66, 0x66, 0xed, 0x0d, 0x00, 0x0b, 
	0x03, 0x73, 0x00, 0x3f, 0x00, 0x0c, 0x00, 0x0d, 0x00, 0x08, 0x11, 
	0x1f, 0x3f, 0x25, 0x00, 0x0e, 0xf8, 0xed, 0x6e, 0xd6, 0xfc, 0xfc, 
	0xfd, 0x54, 0x27, 0x27, 0x67, 0x63, 0x6e, 0x0e, 0xcd, 0xed, 0xfc, 
	0xf8, 0x54, 0x3f, 0x27, 0x3f, 0x33, 0x3e, 0x3c, 0x42, 0x3f, 0x3f, 
	0x3f, 0x3f, 0x42, 0x3c, 0x21, 0x04, 0x01, 0x11, 0xb3, 0x00, 0x1a, 
	0x13, 0x3f, 0x20, 0xc0, 0x23, 0x7d, 0xc0, 0x34, 0x20, 0xc8, 0x06, 
	0x19, 0x78, 0x8a, 0x23, 0x05, 0x20, 0xd9, 0x8a, 0x20, 0xc0, 0x3e, 
	0x01, 0xc1, 0x50,
];

class Memory
{
	Emulator emulator;

	ubyte[0x8000] cartridge; // 0x0000 - 0x7FFF
	ubyte[0x2000] vram; // 0x8000 - 0x9FFF
	ubyte[0x2000] extram; // 0xA000 - 0xBFFF
	ubyte[0x2000] wram; // 0xC000 - 0xDFFF
	// Mirror of wram 0xE000 - 0xFDFF
	ubyte[0x100] oam; // 0xFE00 - 0xFE9F
	// Not usable 0xFEA0 - 0xFEFF
	ubyte[0x100] io; // 0xFF00 - 0xFF7F
	ubyte[0x80] hram; // 0xFF80 - 0xFFFE

	this(Emulator emulator) {
		this.emulator = emulator;
	}

	ubyte opIndex(ushort address) {
		return getReference(address);
	}

	auto opSlice(size_t x, size_t y) {
		ubyte[] tbl;

		foreach(i; x .. y)
			tbl ~= getReference(cast(ushort)i);

		return tbl;
	}

	void opIndexAssign(ubyte value, ushort address) {
		getReference(address) = value;
	}

	void opIndexAssign(ushort value, ushort address) {
		getReference(address) = value >> 8;
		getReference(cast(ushort)(address + 1)) = value & 0xFF;
	}

	ref ubyte getReference(ushort address) {
		if(address >= 0x0000 && address <= 0x7FFF)
			return cartridge[address];

		if(address >= 0x8000 && address <= 0x9FFF)
			return vram[address - 0x8000];

		if(address >= 0xA000 && address <= 0xBFFF)
			return extram[address - 0xA000];

		if(address >= 0xC000 && address <= 0xDFFF)
			return wram[address - 0xC000];

		if(address >= 0xE000 && address <= 0xFDFF)
			return wram[address - 0xE000];

		if(address >= 0xFE00 && address <= 0xFEFF)
			return oam[address - 0xFE00];

		if(address >= 0xFF00 && address <= 0xFF7F)
			return io[address - 0xFF00];

		if(address >= 0xFF80 && address <= 0xFFFE)
			return hram[address - 0xFF80];

		if(address == 0xFFFF)
			return emulator.interrupts.enable;

		throw new Exception("Invalid memory reference " ~ address.to!string(16));
	}

	void loadRom(ubyte[] data) {
		cartridge[0 .. data.length] = data;
		cartridge[0 .. 0x100] = bootstrapRom;
	}
}

unittest {
	import std.random;

	Memory memory;

	foreach(i; 0 .. 0x7FFF) {
		ubyte value = cast(ubyte)uniform(0, 255);
		//memory[cast(ushort)i] = value;
		//assert(memory[cast(ushort)i] == value);
	}
}